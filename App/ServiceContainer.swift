import Foundation
import Shared
import Database
import Storage
import Capture
import Processing
import Search
import Migration

/// Dependency injection container for all app services
/// Owner: APP integration
public actor ServiceContainer {

    // MARK: - Services

    public let database: DatabaseManager
    public let ftsEngine: FTSManager
    public let storage: StorageManager
    public let capture: CaptureManager
    // ⚠️ RELEASE 2 ONLY - Audio not implemented in Release 1
    // public let audioCapture: AudioCaptureManager
    public let processing: ProcessingManager
    // ⚠️ RELEASE 2 ONLY - Audio not implemented in Release 1
    // public let audioProcessing: AudioProcessingManager
    public let search: SearchManager
    public let migration: MigrationManager
    public let modelManager: ModelManager
    nonisolated public let onboardingManager: OnboardingManager
    public var dataAdapter: DataAdapter?

    // MARK: - Configuration

    private let databasePath: String
    private let storageConfig: StorageConfig
    private let captureConfig: CaptureConfig
    // ⚠️ RELEASE 2 ONLY
    // private let audioCaptureConfig: AudioCaptureConfig
    private let processingConfig: ProcessingConfig
    // ⚠️ RELEASE 2 ONLY
    // private let audioProcessingConfig: AudioProcessingConfig
    private let searchConfig: SearchConfig

    private var isInitialized = false

    // MARK: - Initialization

    public init(
        databasePath: String = AppPaths.databasePath,
        storageConfig: StorageConfig = .default,
        captureConfig: CaptureConfig = .default,
        // ⚠️ RELEASE 2 ONLY
        // audioCaptureConfig: AudioCaptureConfig = .default,
        processingConfig: ProcessingConfig = .default,
        // ⚠️ RELEASE 2 ONLY
        // audioProcessingConfig: AudioProcessingConfig = .default,
        searchConfig: SearchConfig = .default
    ) {
        self.databasePath = databasePath
        self.storageConfig = storageConfig
        self.captureConfig = captureConfig
        // ⚠️ RELEASE 2 ONLY
        // self.audioCaptureConfig = audioCaptureConfig
        self.processingConfig = processingConfig
        // ⚠️ RELEASE 2 ONLY
        // self.audioProcessingConfig = audioProcessingConfig
        self.searchConfig = searchConfig

        // Initialize all managers
        self.database = DatabaseManager(databasePath: databasePath)
        self.ftsEngine = FTSManager(databasePath: databasePath)
        self.storage = StorageManager()
        self.capture = CaptureManager(config: captureConfig)
        // ⚠️ RELEASE 2 ONLY - Audio initialization commented out
        // self.audioCapture = AudioCaptureManager(config: audioCaptureConfig)
        self.processing = ProcessingManager(config: processingConfig)

        // ⚠️ RELEASE 2 ONLY - Audio processing initialization commented out
        // // Audio processing initialized later after database is ready
        // // Load model path from config file (generated by setup_whisper.sh) or use default
        // let modelPath = WhisperConfigLoader.getModelPath()
        // if WhisperConfigLoader.loadConfig() != nil {
        //     Log.info("Using whisper.cpp config from: \(WhisperConfigLoader.defaultConfigPath)", category: .app)
        //     Log.info("Model: \(modelPath)", category: .app)
        //     if WhisperConfigLoader.isCoreMLEnabled() {
        //         Log.info("CoreML acceleration: enabled", category: .app)
        //     }
        // } else {
        //     Log.warning("whisper_config.json not found, using default model path", category: .app)
        //     Log.info("Model: \(modelPath)", category: .app)
        // }
        //
        // let transcriptionService = WhisperCppTranscriptionService(
        //     modelPath: modelPath,
        //     coreMLModelPath: WhisperConfigLoader.getCoreMLModelPath()
        // )
        //
        // // Audio storage writer
        // let storageRoot = URL(fileURLWithPath: storageConfig.expandedStorageRootPath, isDirectory: true)
        // let audioWriter = AudioSegmentWriter(storageRoot: storageRoot)
        //
        // self.audioProcessing = AudioProcessingManager(
        //     transcriptionService: transcriptionService,
        //     transcriptionQueries: nil,  // Set during initialization
        //     audioWriter: audioWriter,
        //     config: audioProcessingConfig
        // )

        // FTS-only search manager
        self.search = SearchManager(
            database: database,
            ftsEngine: ftsEngine
        )

        // Migration depends on database and processing
        self.migration = MigrationManager(
            database: database,
            processing: processing
        )

        // Model and onboarding managers
        self.modelManager = ModelManager()
        self.onboardingManager = OnboardingManager()

        Log.info("ServiceContainer created", category: .app)
    }

    /// Convenience initializer for in-memory/testing
    public init(inMemory: Bool) {
        // Use shared in-memory database so DatabaseManager and FTSManager use the same DB
        let sharedMemoryPath = "file:memdb_test_\(UUID().uuidString)?mode=memory&cache=shared"
        self.databasePath = sharedMemoryPath
        self.storageConfig = .default
        self.captureConfig = .default
        // ⚠️ RELEASE 2 ONLY
        // self.audioCaptureConfig = .default
        self.processingConfig = .default
        // ⚠️ RELEASE 2 ONLY
        // self.audioProcessingConfig = .default
        self.searchConfig = .default

        self.database = DatabaseManager(databasePath: sharedMemoryPath)
        self.ftsEngine = FTSManager(databasePath: sharedMemoryPath)
        self.storage = StorageManager()
        self.capture = CaptureManager()
        // ⚠️ RELEASE 2 ONLY
        // self.audioCapture = AudioCaptureManager()
        self.processing = ProcessingManager()

        // ⚠️ RELEASE 2 ONLY - Audio processing initialization commented out
        // // Audio processing initialized later after database is ready
        // // Use mock transcription service in test mode to avoid loading heavy Whisper model
        // let transcriptionService: any TranscriptionProtocol
        // if inMemory {
        //     transcriptionService = MockTranscriptionService()
        // } else {
        //     // Load model path from config file (generated by setup_whisper.sh) or use default
        //     let modelPath = WhisperConfigLoader.getModelPath()
        //     transcriptionService = WhisperCppTranscriptionService(
        //         modelPath: modelPath,
        //         coreMLModelPath: WhisperConfigLoader.getCoreMLModelPath()
        //     )
        // }
        // let storageRoot = URL(fileURLWithPath: "/tmp/retrace_test", isDirectory: true)
        // let audioWriter = AudioSegmentWriter(storageRoot: storageRoot)
        // self.audioProcessing = AudioProcessingManager(
        //     transcriptionService: transcriptionService,
        //     transcriptionQueries: nil,  // Set during initialization
        //     audioWriter: audioWriter,
        //     config: .default
        // )

        // FTS-only search manager
        self.search = SearchManager(
            database: database,
            ftsEngine: ftsEngine
        )

        self.migration = MigrationManager(
            database: database,
            processing: processing
        )

        // Model and onboarding managers
        self.modelManager = ModelManager()
        self.onboardingManager = OnboardingManager()

        Log.info("ServiceContainer created (in-memory mode)", category: .app)
    }

    // MARK: - Lifecycle

    /// Initialize all services in the correct order
    public func initialize() async throws {
        guard !isInitialized else {
            Log.warning("ServiceContainer already initialized", category: .app)
            return
        }

        Log.info("Initializing all services...", category: .app)

        // 1. Initialize database first (creates schema)
        try await database.initialize()
        Log.info("✓ Database initialized", category: .app)

        // 2. Initialize FTS engine (shares same database)
        try await ftsEngine.initialize()
        Log.info("✓ FTS engine initialized", category: .app)

        // 3. Initialize storage (creates directories, loads encryption key)
        try await storage.initialize(config: storageConfig)
        Log.info("✓ Storage initialized", category: .app)

        // 4. Initialize processing (sets config)
        try await processing.initialize(config: processingConfig)
        Log.info("✓ Processing initialized", category: .app)

        // ⚠️ RELEASE 2 ONLY - Audio processing initialization commented out
        // // 5. Initialize audio processing (loads whisper.cpp model and connects to database)
        // guard let dbPointer = await database.getConnection() else {
        //     throw ServiceError.databaseNotReady
        // }
        // let audioTranscriptionQueries = AudioTranscriptionQueries(db: dbPointer)
        // let storageRoot = await storage.getStorageDirectory()
        // let audioWriter = AudioSegmentWriter(storageRoot: storageRoot)
        // try await audioProcessing.initialize(
        //     transcriptionQueries: audioTranscriptionQueries,
        //     audioWriter: audioWriter
        // )
        // Log.info("✓ Audio processing initialized", category: .app)

        // 6. Initialize search manager
        try await search.initialize(config: searchConfig)
        Log.info("✓ Search initialized", category: .app)

        // 7. Migration doesn't need explicit initialization
        Log.info("✓ Migration ready", category: .app)

        // 8. Initialize DataAdapter with primary and secondary sources
        let retraceSource = RetraceDataSource(database: database, storage: storage, searchManager: search)
        let adapter = DataAdapter(primarySource: retraceSource)

        // Register Rewind source if user opted in
        let useRewindData = UserDefaults.standard.bool(forKey: "useRewindData")
        Log.info("Checking Rewind source during initialization: useRewindData=\(useRewindData)", category: .app)

        if useRewindData {
            // Hardcoded password for Rewind database decryption
            let rewindPassword = "soiZ58XZJhdka55hLUp18yOtTUTDXz7Diu7Z4JzuwhRwGG13N6Z9RTVU1fGiKkuF"
            do {
                let rewindSource = try RewindDataSource(password: rewindPassword)
                await adapter.registerSource(rewindSource)
                Log.info("✓ Rewind source registered during initialization", category: .app)
            } catch {
                Log.warning("Failed to create Rewind source during initialization: \(error)", category: .app)
            }
        } else {
            Log.info("⊘ Rewind source not registered during initialization (useRewindData is false)", category: .app)
        }

        // Initialize the adapter (connects all sources)
        try await adapter.initialize()
        self.dataAdapter = adapter
        Log.info("✓ DataAdapter initialized", category: .app)

        // Capture is initialized when startCapture() is called

        isInitialized = true
        Log.info("All services initialized successfully", category: .app)
    }

    /// Register Rewind data source if user has opted in
    /// Can be called after initialization (e.g., after onboarding completes)
    public func registerRewindSourceIfEnabled() async throws {
        guard isInitialized else {
            Log.warning("Cannot register Rewind source - ServiceContainer not initialized", category: .app)
            return
        }

        guard let adapter = dataAdapter else {
            Log.warning("Cannot register Rewind source - DataAdapter not available", category: .app)
            return
        }

        let useRewindData = UserDefaults.standard.bool(forKey: "useRewindData")
        Log.info("Checking if Rewind source should be registered: useRewindData=\(useRewindData)", category: .app)

        if useRewindData {
            // Check if already registered
            let sources = await adapter.registeredSources
            if sources.contains(.rewind) {
                Log.info("Rewind source already registered, skipping", category: .app)
                return
            }

            // Hardcoded password for Rewind database decryption
            let rewindPassword = "soiZ58XZJhdka55hLUp18yOtTUTDXz7Diu7Z4JzuwhRwGG13N6Z9RTVU1fGiKkuF"
            do {
                let rewindSource = try RewindDataSource(password: rewindPassword)
                await adapter.registerSource(rewindSource)
                try await rewindSource.connect()
                Log.info("✓ Rewind source registered and connected after initialization", category: .app)
            } catch {
                Log.warning("Failed to create Rewind source: \(error)", category: .app)
                throw error
            }
        } else {
            Log.info("⊘ Rewind source not registered (useRewindData is false)", category: .app)
        }
    }

    /// Shutdown all services gracefully
    public func shutdown() async throws {
        guard isInitialized else { return }

        Log.info("Shutting down all services...", category: .app)

        // Stop capture if running
        if await capture.isCapturing {
            try await capture.stopCapture()
            Log.info("✓ Capture stopped", category: .app)
        }

        // ⚠️ RELEASE 2 ONLY - Audio capture stop commented out
        // // Stop audio capture if running
        // if await audioCapture.isCapturing {
        //     try await audioCapture.stopCapture()
        //     Log.info("✓ Audio capture stopped", category: .app)
        // }

        // Wait for processing queue to drain
        await processing.waitForQueueDrain()
        Log.info("✓ Processing queue drained", category: .app)

        // ⚠️ RELEASE 2 ONLY
        // // Audio processing will complete when stream ends
        // Log.info("✓ Audio processing drained", category: .app)

        // Shutdown DataAdapter (disconnects all sources)
        await dataAdapter?.shutdown()
        Log.info("✓ DataAdapter shutdown", category: .app)

        // Close database connections
        try await ftsEngine.close()
        Log.info("✓ FTS engine closed", category: .app)

        try await database.close()
        Log.info("✓ Database closed", category: .app)

        isInitialized = false
        Log.info("All services shutdown successfully", category: .app)
    }

    // MARK: - Service Access

    /// Check if services are initialized
    public var initialized: Bool {
        isInitialized
    }

    /// Get database statistics
    public func getDatabaseStats() async throws -> DatabaseStatistics {
        try await database.getStatistics()
    }

    /// Get search statistics
    public func getSearchStats() async -> SearchStatistics {
        await search.getStatistics()
    }

    /// Get capture statistics
    public func getCaptureStats() async -> CaptureStatistics {
        await capture.getStatistics()
    }

    /// Get processing statistics
    public func getProcessingStats() async -> ProcessingStatistics {
        await processing.getStatistics()
    }
}

// MARK: - Default Configurations

extension StorageConfig {
    public static var `default`: StorageConfig {
        // Read settings from UserDefaults (synced with Settings UI)
        // Defaults: retention = forever (0/nil), storage = unlimited (500GB max)
        let retentionDays = UserDefaults.standard.object(forKey: "retentionDays") as? Int ?? 0
        let maxStorageGB = UserDefaults.standard.object(forKey: "maxStorageGB") as? Double ?? 500.0

        return StorageConfig(
            storageRootPath: AppPaths.storageRoot,
            retentionDays: retentionDays == 0 ? nil : retentionDays, // 0 = forever
            maxStorageGB: maxStorageGB,
            segmentDurationSeconds: 300  // 5 minutes
        )
    }
}

extension CaptureConfig {
    public static var `default`: CaptureConfig {
        // Read settings from UserDefaults (synced with Settings UI)
        let captureRate = UserDefaults.standard.object(forKey: "captureRate") as? Double ?? 0.5
        // Default to false - capture everything (private windows exclusion not implemented yet)
        let excludePrivateWindows = UserDefaults.standard.object(forKey: "excludePrivateWindows") as? Bool ?? false

        return CaptureConfig(
            captureIntervalSeconds: 1.0 / captureRate, // Convert FPS to interval
            adaptiveCaptureEnabled: true,
            deduplicationThreshold: 0.90, // 0.90 = strict (filters static/similar frames, keeps only >10% different)
            maxResolution: .uhd4K,
            excludedAppBundleIDs: [], // Empty - no apps excluded by default
            excludePrivateWindows: excludePrivateWindows
        )
    }
}

extension ProcessingConfig {
    public static var `default`: ProcessingConfig {
        ProcessingConfig(
            accessibilityEnabled: true,
            ocrAccuracyLevel: .accurate,
            recognitionLanguages: ["en-US"],
            minimumConfidence: 0.5
        )
    }
}

extension SearchConfig {
    public static var `default`: SearchConfig {
        SearchConfig(
            semanticSearchEnabled: false,  // Semantic search disabled
            defaultResultLimit: 50,
            minimumRelevanceScore: 0.1
        )
    }
}

// ⚠️ RELEASE 2 ONLY - Audio config extensions commented out
// extension AudioCaptureConfig {
//     public static var `default`: AudioCaptureConfig {
//         AudioCaptureConfig(
//             microphoneEnabled: true,
//             systemAudioEnabled: true,
//             voiceProcessingEnabled: true,
//             hasConsentedToMeetingRecording: false,
//             bufferDurationSeconds: 30.0,
//             targetSampleRate: 16000,
//             targetChannels: 1,
//             meetingAppBundleIDs: AudioCaptureConfig.defaultMeetingApps
//         )
//     }
// }
//
// extension AudioProcessingConfig {
//     public static var `default`: AudioProcessingConfig {
//         AudioProcessingConfig(
//             enableWordLevelTimestamps: true,
//             minimumConfidence: 0.5,
//             maxBufferDuration: 30.0,
//             transcriptionCallback: nil
//         )
//     }
// }

// MARK: - Errors

enum ServiceError: Error {
    case databaseNotReady
}
