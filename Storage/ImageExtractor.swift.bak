import Foundation
import AppKit
import AVFoundation
import Shared

/// Protocol for extracting frame images from video storage
/// Abstracts the difference between Retrace (HEVC via StorageManager) and Rewind (MP4 via AVAsset)
public protocol ImageExtractor: Sendable {
    /// Extract a single frame from video storage
    /// - Parameters:
    ///   - videoPath: Path to the video file (may be relative or absolute)
    ///   - frameIndex: Frame index within the video
    ///   - frameRate: Frame rate of the video (optional, used for time calculation)
    /// - Returns: JPEG image data
    func extractFrame(videoPath: String, frameIndex: Int, frameRate: Double?) async throws -> Data
}

// MARK: - HEVC Storage Extractor (Retrace)

/// Cached AVAssetImageGenerator with its symlink (if needed)
private final class CachedImageGenerator {
    let generator: AVAssetImageGenerator
    let symlinkURL: URL?  // Keep symlink alive while generator is cached

    init(generator: AVAssetImageGenerator, symlinkURL: URL?) {
        self.generator = generator
        self.symlinkURL = symlinkURL
    }

    deinit {
        // Clean up symlink when evicted from cache
        if let symlinkURL = symlinkURL {
            try? FileManager.default.removeItem(at: symlinkURL)
        }
    }
}

/// Image extractor for Retrace's custom HEVC storage
/// Uses AVAssetImageGenerator for fast single-frame extraction with generator caching
public final class HEVCStorageExtractor: ImageExtractor {
    private let storageRoot: String
    private nonisolated(unsafe) let imageCache = NSCache<NSString, NSData>()
    private nonisolated(unsafe) let generatorCache = NSCache<NSString, CachedImageGenerator>()

    public init(storageManager: StorageManager) {
        // Get storage root from StorageConfig default
        self.storageRoot = StorageConfig.default.expandedStorageRootPath
        // Configure cache to store ~100 extracted frames
        imageCache.countLimit = 100
        // Approximate 50KB per JPEG = 5MB total cache
        imageCache.totalCostLimit = 5 * 1024 * 1024
        // Cache up to 10 image generators (one per video segment)
        generatorCache.countLimit = 10
    }

    public init(storageRoot: String) {
        self.storageRoot = storageRoot
        imageCache.countLimit = 100
        imageCache.totalCostLimit = 5 * 1024 * 1024
        generatorCache.countLimit = 10
    }

    public func extractFrame(videoPath: String, frameIndex: Int, frameRate: Double?) async throws -> Data {
        // Check image cache first
        let frameCacheKey = "\(videoPath)_\(frameIndex)" as NSString
        if let cached = imageCache.object(forKey: frameCacheKey) {
            return cached as Data
        }

        // Construct full path
        var fullVideoPath: String
        if videoPath.hasPrefix("/") {
            fullVideoPath = videoPath
        } else {
            fullVideoPath = "\(storageRoot)/\(videoPath)"
        }

        // Get or create cached image generator for this video
        let generatorCacheKey = fullVideoPath as NSString
        let imageGenerator: AVAssetImageGenerator

        if let cached = generatorCache.object(forKey: generatorCacheKey) {
            // Verify symlink still exists (macOS may clean up temp files)
            if let symlinkURL = cached.symlinkURL {
                if !FileManager.default.fileExists(atPath: symlinkURL.path) {
                    // Symlink was cleaned up - invalidate cache and recreate
                    generatorCache.removeObject(forKey: generatorCacheKey)
                    return try await extractFrame(videoPath: videoPath, frameIndex: frameIndex, frameRate: frameRate)
                }
            }
            imageGenerator = cached.generator
        } else {
            // Check if file exists
            if !FileManager.default.fileExists(atPath: fullVideoPath) {
                throw ImageExtractionError.invalidPath(fullVideoPath)
            }

            // Check if file is empty (still being written)
            let fileSize = (try? FileManager.default.attributesOfItem(atPath: fullVideoPath)[.size] as? Int64) ?? 0
            if fileSize == 0 {
                Log.warning("[HEVCStorageExtractor] Video file is empty (0 bytes), still being written: \(fullVideoPath)", category: .storage)
                throw ImageExtractionError.extractionFailed(
                    path: fullVideoPath,
                    frameIndex: frameIndex,
                    error: NSError(domain: "HEVCStorageExtractor", code: -1, userInfo: [NSLocalizedDescriptionKey: "Video file is empty (still being written)"])
                )
            }

            // Handle extensionless files by creating symlink
            let originalURL = URL(fileURLWithPath: fullVideoPath)
            let assetURL: URL
            var symlinkURL: URL? = nil

            if originalURL.pathExtension.lowercased() == "mp4" {
                assetURL = originalURL
            } else {
                // Create symlink with .mp4 extension (kept alive by CachedImageGenerator)
                let tempPath = FileManager.default.temporaryDirectory
                    .appendingPathComponent(UUID().uuidString + ".mp4")
                symlinkURL = tempPath

                do {
                    try FileManager.default.createSymbolicLink(
                        at: tempPath,
                        withDestinationURL: originalURL
                    )
                } catch {
                    throw ImageExtractionError.symlinkFailed(path: fullVideoPath, error: error)
                }
                assetURL = tempPath
            }

            // Create and configure the image generator
            let asset = AVAsset(url: assetURL)
            let generator = AVAssetImageGenerator(asset: asset)
            generator.appliesPreferredTrackTransform = true
            generator.requestedTimeToleranceAfter = .zero
            generator.requestedTimeToleranceBefore = .zero

            // Cache the generator (symlink cleanup handled by CachedImageGenerator deinit)
            let cachedGenerator = CachedImageGenerator(generator: generator, symlinkURL: symlinkURL)
            generatorCache.setObject(cachedGenerator, forKey: generatorCacheKey)
            imageGenerator = generator
        }

        // Calculate CMTime from frame index
        let effectiveFrameRate = frameRate ?? 30.0
        let time: CMTime
        if effectiveFrameRate == 30.0 {
            time = CMTime(value: Int64(frameIndex) * 20, timescale: 600)
        } else {
            let timeInSeconds = Double(frameIndex) / effectiveFrameRate
            time = CMTime(seconds: timeInSeconds, preferredTimescale: 600)
        }

        // Extract frame using cached generator
        let cgImage: CGImage
        do {
            cgImage = try imageGenerator.copyCGImage(at: time, actualTime: nil)
        } catch {
            // Invalidate cache on error (file might have changed)
            generatorCache.removeObject(forKey: generatorCacheKey)
            throw ImageExtractionError.extractionFailed(
                path: fullVideoPath,
                frameIndex: frameIndex,
                error: error
            )
        }

        // Convert to JPEG
        let nsImage = NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
        guard let tiffData = nsImage.tiffRepresentation,
              let bitmapImage = NSBitmapImageRep(data: tiffData),
              let jpegData = bitmapImage.representation(
                using: .jpeg,
                properties: [.compressionFactor: 0.8]
              ) else {
            throw ImageExtractionError.conversionFailed(path: fullVideoPath)
        }

        // Cache the result
        imageCache.setObject(jpegData as NSData, forKey: frameCacheKey, cost: jpegData.count)
        return jpegData
    }
}

// MARK: - AVAsset Extractor (Rewind)

/// Image extractor for Rewind's MP4 videos using AVFoundation
/// Handles the symlink hack needed for extensionless MP4 files
public final class AVAssetExtractor: ImageExtractor {
    private nonisolated(unsafe) let imageCache = NSCache<NSString, NSData>()
    private nonisolated(unsafe) let generatorCache = NSCache<NSString, CachedImageGenerator>()
    private let storageRoot: String

    public init(storageRoot: String) {
        self.storageRoot = storageRoot
        // Configure cache to store ~100 extracted frames
        imageCache.countLimit = 100
        // Approximate 50KB per JPEG = 5MB total cache
        imageCache.totalCostLimit = 5 * 1024 * 1024
        // Cache up to 10 image generators (one per video file)
        generatorCache.countLimit = 10
    }

    public func extractFrame(videoPath: String, frameIndex: Int, frameRate: Double?) async throws -> Data {
        // Check image cache first
        let frameCacheKey = "\(videoPath)_\(frameIndex)" as NSString
        if let cached = imageCache.object(forKey: frameCacheKey) {
            return cached as Data
        }

        // Construct full path from storage root
        var fullVideoPath: String
        if videoPath.hasPrefix("/") {
            fullVideoPath = videoPath
        } else {
            fullVideoPath = "\(storageRoot)/\(videoPath)"
        }

        // Check if file exists - if not, try with .mp4 extension
        if !FileManager.default.fileExists(atPath: fullVideoPath) {
            let pathWithExtension = fullVideoPath + ".mp4"
            if FileManager.default.fileExists(atPath: pathWithExtension) {
                fullVideoPath = pathWithExtension
            }
        }

        // Get or create cached image generator for this video
        let generatorCacheKey = fullVideoPath as NSString
        let imageGenerator: AVAssetImageGenerator

        if let cached = generatorCache.object(forKey: generatorCacheKey) {
            // Verify symlink still exists (macOS may clean up temp files)
            if let symlinkURL = cached.symlinkURL {
                if !FileManager.default.fileExists(atPath: symlinkURL.path) {
                    // Symlink was cleaned up - invalidate cache and recreate
                    generatorCache.removeObject(forKey: generatorCacheKey)
                    return try await extractFrame(videoPath: videoPath, frameIndex: frameIndex, frameRate: frameRate)
                }
            }
            imageGenerator = cached.generator
        } else {
            // Check if file is empty (incomplete/damaged video)
            let fileSize = (try? FileManager.default.attributesOfItem(atPath: fullVideoPath)[.size] as? Int64) ?? 0
            if fileSize == 0 {
                Log.warning("[AVAssetExtractor] Video file is empty (0 bytes), still being written: \(fullVideoPath)", category: .storage)
                throw ImageExtractionError.extractionFailed(
                    path: fullVideoPath,
                    frameIndex: frameIndex,
                    error: NSError(domain: "AVAssetExtractor", code: -1, userInfo: [NSLocalizedDescriptionKey: "Video file is empty (still being written)"])
                )
            }

            // Handle extensionless files by creating symlink
            let originalURL = URL(fileURLWithPath: fullVideoPath)
            let assetURL: URL
            var symlinkURL: URL? = nil

            if originalURL.pathExtension.lowercased() == "mp4" {
                assetURL = originalURL
            } else {
                // Create symlink with .mp4 extension (kept alive by CachedImageGenerator)
                let tempPath = FileManager.default.temporaryDirectory
                    .appendingPathComponent(UUID().uuidString + ".mp4")
                symlinkURL = tempPath

                do {
                    try FileManager.default.createSymbolicLink(
                        at: tempPath,
                        withDestinationURL: originalURL
                    )
                } catch {
                    throw ImageExtractionError.symlinkFailed(path: fullVideoPath, error: error)
                }
                assetURL = tempPath
            }

            // Create and configure the image generator
            let asset = AVAsset(url: assetURL)
            let generator = AVAssetImageGenerator(asset: asset)
            generator.appliesPreferredTrackTransform = true
            generator.requestedTimeToleranceAfter = .zero
            generator.requestedTimeToleranceBefore = .zero

            // Cache the generator (symlink cleanup handled by CachedImageGenerator deinit)
            let cachedGenerator = CachedImageGenerator(generator: generator, symlinkURL: symlinkURL)
            generatorCache.setObject(cachedGenerator, forKey: generatorCacheKey)
            imageGenerator = generator
        }

        // Calculate CMTime from frame index
        let effectiveFrameRate = frameRate ?? 30.0
        let time: CMTime
        if effectiveFrameRate == 30.0 {
            time = CMTime(value: Int64(frameIndex) * 20, timescale: 600)
        } else {
            let timeInSeconds = Double(frameIndex) / effectiveFrameRate
            time = CMTime(seconds: timeInSeconds, preferredTimescale: 600)
        }

        // Extract frame using cached generator
        let cgImage: CGImage
        do {
            cgImage = try imageGenerator.copyCGImage(at: time, actualTime: nil)
        } catch {
            // Invalidate cache on error (file might have changed)
            generatorCache.removeObject(forKey: generatorCacheKey)
            throw ImageExtractionError.extractionFailed(
                path: fullVideoPath,
                frameIndex: frameIndex,
                error: error
            )
        }

        // Convert to JPEG
        let nsImage = NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
        guard let tiffData = nsImage.tiffRepresentation,
              let bitmapImage = NSBitmapImageRep(data: tiffData),
              let jpegData = bitmapImage.representation(
                using: .jpeg,
                properties: [.compressionFactor: 0.8]
              ) else {
            throw ImageExtractionError.conversionFailed(path: fullVideoPath)
        }

        // Cache the result
        imageCache.setObject(jpegData as NSData, forKey: frameCacheKey, cost: jpegData.count)
        return jpegData
    }
}

// MARK: - Errors

public enum ImageExtractionError: Error, CustomStringConvertible {
    case invalidPath(String)
    case symlinkFailed(path: String, error: Error)
    case extractionFailed(path: String, frameIndex: Int, error: Error)
    case conversionFailed(path: String)

    public var description: String {
        switch self {
        case .invalidPath(let path):
            return "Invalid video path: \(path)"
        case .symlinkFailed(let path, let error):
            return "Failed to create symlink for \(path): \(error.localizedDescription)"
        case .extractionFailed(let path, let frameIndex, let error):
            return "Failed to extract frame \(frameIndex) from \(path): \(error.localizedDescription)"
        case .conversionFailed(let path):
            return "Failed to convert extracted image to JPEG for \(path)"
        }
    }
}
